=========================================
        ğŸ“š Jenkins Shared Libraries
=========================================

Today I learned about **Jenkins Shared Libraries**, which allow us to store
reusable pipeline code in a central Git repository.

This is used in real-world CI/CD setups to avoid repeating the same
pipeline logic across multiple Jenkinsfiles.


=========================================
1. ğŸ§© What Are Shared Libraries?
=========================================

Shared Libraries let developers:

- Write reusable functions, steps, and pipeline logic
- Maintain common CI/CD logic in one place
- Reduce copy-paste across multiple pipelines
- Keep Jenkinsfiles clean and simple

A Shared Library is typically stored in a Git repository and contains:

- vars/        â†’ Groovy scripts accessible as functions
- src/         â†’ Groovy classes and packages
- resources/   â†’ Templates, YAML, files
- Jenkinsfile or documentation


=========================================
2. ğŸ›  Example Usage
=========================================

Suppose I create a shared function in:

vars/hello.groovy:

def call() {
    echo "Hello from Shared Library!"
}

In my Jenkinsfile:

@Library('my-shared-lib') _
pipeline {
    agent any
    stages {
        stage('Test') {
            steps {
                hello()     // calling shared library function
            }
        }
    }
}

This makes pipelines cleaner and easier to maintain.


=========================================
3. ğŸš€ Real-World Usage of Shared Libraries
=========================================

Companies use Shared Libraries to handle:

- Standard build stages for all services
- Security scanning steps
- Docker build and push functions
- Kubernetes deployment logic
- Notification patterns (Slack, Teams, Email)
- Reusable helper functions (Git tag, versioning, etc.)

It ensures all projects follow the same CI/CD standards.


=========================================
        ğŸ‘¥ Jenkins Role-Based Access Control
=========================================

I also learned about **user-based role management** in Jenkins, used to
control what each user can see or do.

This is essential for production Jenkins setups.


=========================================
4. ğŸ” Role-Based Strategy Plugin
=========================================

Jenkins uses the **Role-Based Authorization Strategy** plugin to manage:

- Global Roles
- Project Roles
- Agent (Node) Roles

Examples:

- Admin â†’ Full control
- Developer â†’ Create pipelines, run builds
- Viewer â†’ Read-only access
- DevOps â†’ Manage nodes and credentials

This helps prevent unauthorized access to:

- Pipelines
- Credentials
- Build logs
- Deployment jobs


=========================================
5. ğŸ§­ How Roles Are Assigned
=========================================

Steps I learned:

1. Install **Role-Based Strategy Plugin**
2. Go to *Manage Jenkins â†’ Configure Global Security*
3. Choose **Role-Based Authorization Strategy**
4. Create roles:
   - global roles
   - project roles
5. Assign roles to users or groups

This keeps Jenkins secure and organized.


=========================================
6. ğŸŒ Real-World Usage of RBAC
=========================================

Used for:

- Restricting junior developers from editing production pipelines
- Allowing testers to trigger only specific jobs
- Protecting cloud credentials and secrets
- Enforcing enterprise security policies
- Giving DevOps full access while limiting others


=========================================
âœ… Summary of Today
=========================================

âœ” Understood Jenkins Shared Libraries
âœ” Learned how to create reusable pipeline stages
âœ” Saw how real companies maintain centralized CI/CD logic
âœ” Understood user-based role management
âœ” Learned how roles secure projects and credentials
âœ” Saw how RBAC is essential for production Jenkins