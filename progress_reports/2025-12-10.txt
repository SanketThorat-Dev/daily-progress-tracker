=========================================
   ğŸš€ Kubernetes â€“ Deployments, ReplicaSets,
      Labels/Selectors & Rolling Updates
=========================================

Today I learned some of the MOST important Kubernetes concepts:
**Deployments, ReplicaSets, Labels & Selectors, and Rolling Updates.**

These are the backbone of real-world Kubernetes applications.


=========================================
1. ğŸ§± ReplicaSets (RS)
=========================================

A **ReplicaSet** ensures that a specified number of pod replicas
are always running.

ReplicaSet responsibilities:
- Keep the desired number of pods running
- Restart pods if they fail
- Replace pods if they are deleted

ReplicaSets use **labels & selectors** to identify which pods belong to
them.

Commands I learned:

Get ReplicaSets:
kubectl get rs

Scale a ReplicaSet:
kubectl scale rs myapp-rs --replicas=5


=========================================
2. ğŸš€ Deployments
=========================================

A **Deployment** is a higher-level object that manages ReplicaSets.

Deployment responsibilities:
- Create / update ReplicaSets
- Handle rolling updates
- Rollback to previous versions
- Ensure zero downtime deployments

A Deployment is what is commonly used in production â€” NOT pods or
ReplicaSets directly.

Example Deployment structure:

apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
        - name: app
          image: nginx:latest


=========================================
3. ğŸ·ï¸ Labels & Selectors
=========================================

Labels = key/value pairs attached to Kubernetes objects
Selectors = used to filter objects by labels

Examples:

Labels:
app: frontend
env: dev

Selectors:
matchLabels:
  app: frontend

Why they matter:
- Deployments match Pods through labels
- Services match Pods through labels
- ReplicaSets identify pod groups using labels
- Makes filtering & grouping very easy

List pods with a label:
kubectl get pods -l app=myapp


=========================================
4. ğŸ”„ Rolling Updates in Deployments
=========================================

Rolling updates allow you to update your application WITHOUT downtime.

When the image changes:
- Deployment creates a new ReplicaSet
- Pods from the old version are gradually reduced
- Pods from the new version are gradually added
- Users experience zero downtime

Commands I learned:

Apply new version:
kubectl set image deployment/myapp app=nginx:1.25

Check rollout status:
kubectl rollout status deployment/myapp

Rollback:
kubectl rollout undo deployment/myapp


=========================================
5. ğŸ§  Key Concepts I Understood Today
=========================================

âœ” Deployments manage ReplicaSets
âœ” ReplicaSets manage Pods
âœ” Labels connect Deployments â†’ ReplicaSets â†’ Pods
âœ” Selectors identify which pods belong to which RS/Deployment
âœ” Rolling updates ensure zero downtime
âœ” Rollbacks allow quick recovery from failures


=========================================
6. ğŸŒ Real-World Usage
=========================================

Deployments are used for:
- Running stateless microservices
- Managing scalable production workloads
- Zero-downtime upgrades
- Canary / Blue-Green strategies
- Quick rollbacks when something breaks

Labels & selectors are used for:
- Service discovery
- Traffic routing
- Organizing workloads (env, team, app)
- Monitoring & logging dashboards
- Policy enforcement


=========================================
âœ… Summary of Today
=========================================

âœ” Learned Deployments, ReplicaSets
âœ” Practiced labels & selectors
âœ” Performed rolling updates
âœ” Understood Deployment rollbacks
âœ” Strengthened Kubernetes workload fundamentals